<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Tank Battle - Final Layout</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background-color: #2c3e50;
            color: white;
            font-family: 'Press Start 2P', monospace;
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column; 
        }

        /* --- START SCREEN --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #2c3e50; z-index: 9999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; gap: 20px;
        }
        #start-screen h1 { color: #f1c40f; text-align: center; font-size: 1.5rem; margin-bottom: 20px; line-height: 1.5; }
        .mode-btn {
            background: #34495e; color: white; border: 2px solid #7f8c8d;
            padding: 15px 20px; font-family: inherit; font-size: 0.9rem;
            width: 80%; max-width: 300px; cursor: pointer; text-align: center;
        }
        .mode-btn:active { background: #2ecc71; border-color: #27ae60; }

        /* --- GAME CONTAINER --- */
        #game-container {
            display: none; width: 100%; height: 100%; position: relative;
        }

        /* --- MAP AREA --- */
        #game-wrapper {
            background: #000;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; position: relative; z-index: 1;
            flex: 1; /* Default to fill available space */
        }
        canvas {
            background-color: #000; border: 2px solid #7f8c8d;
            image-rendering: pixelated; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%; max-height: 100%; object-fit: contain;
        }

        /* --- SHARED MATH (For Portrait 2) --- */
        #shared-math-display {
            display: none; /* Hidden by default */
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.5); border: 2px solid #f1c40f;
            color: #f1c40f; padding: 5px 10px; border-radius: 5px;
            font-size: 0.7rem; text-align: center; z-index: 50;
            pointer-events: none;
        }

        /* --- CONTROL & INFO STYLES --- */
        .player-info-bar {
            background: #34495e;
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            height: 50px;
            z-index: 10;
        }
        
        .player-stats { font-size: 0.6rem; color: #fff; }
        .math-box {
            background: #000; border: 2px solid #f1c40f; color: #f1c40f;
            padding: 5px; font-size: 0.6rem; border-radius: 4px;
            min-width: 100px; text-align: center;
        }

        /* Controls Overlay Layer */
        .controls-layer {
            position: absolute;
            width: 100%; height: 100%;
            top: 0; left: 0;
            pointer-events: none; /* Let clicks pass through empty space */
            z-index: 20;
        }

        .controls-group {
            position: absolute;
            pointer-events: auto; /* Re-enable clicks */
            display: flex; gap: 10px;
        }

        .dpad {
            display: grid;
            grid-template-columns: 45px 45px 45px;
            grid-template-rows: 45px 45px 45px;
            gap: 3px;
        }
        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px; color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 1rem; cursor: pointer;
        }
        .btn:active, .btn.pressed { background: rgba(255, 255, 255, 0.4); }
        
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 3; }
        .btn-right { grid-column: 3; grid-row: 2; }

        .btn-shoot {
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(231, 76, 60, 0.4); border: 2px solid #c0392b;
            font-size: 0.7rem; display: flex; justify-content: center; align-items: center;
            text-align: center; cursor: pointer; pointer-events: auto;
        }
        .btn-shoot:active, .btn-shoot.pressed { background: #ff6b6b; }


        /* =========================================
           MODE 1: LANDSCAPE (Flex Row)
           ========================================= */
        body.mode-landscape #game-container { display: flex; flex-direction: row; }
        body.mode-landscape #game-wrapper { order: 2; }
        /* Hide the overlay controls and shared bar in this mode, enable sidebars */
        body.mode-landscape .controls-layer, body.mode-landscape #shared-math-display { display: none; }
        /* Note: Landscape needs specific structure not fully refactored here to keep code concise, 
           focusing on Portrait requests. Assuming P1/P2 sidebars exist for Landscape if needed. */


        /* =========================================
           MODE 2: PORTRAIT 1 (HEAD-TO-HEAD)
           ========================================= */
        /* Layout: P2 Info (Top) -> Map (Middle) -> P1 Info (Bottom) */
        
        body.mode-portrait-1 #game-container { display: flex; flex-direction: column; }

        /* P2 INFO BAR (Top) */
        body.mode-portrait-1 #p2-info-bar {
            order: 1; border-bottom: 4px solid #3498db;
            transform: rotate(180deg); /* Rotate for P2 */
        }

        /* MAP (Middle) */
        body.mode-portrait-1 #game-wrapper { order: 2; }

        /* P1 INFO BAR (Bottom) */
        body.mode-portrait-1 #p1-info-bar {
            order: 3; border-top: 4px solid #2ecc71;
        }

        /* CONTROLS OVERLAY */
        body.mode-portrait-1 .controls-layer { display: block; }
        
        /* P1 Controls (Bottom Overlay) */
        body.mode-portrait-1 #p1-controls {
            bottom: 10px; left: 0; width: 100%;
            justify-content: space-between; padding: 0 10px;
            align-items: flex-end;
        }

        /* P2 Controls (Top Overlay - Rotated) */
        body.mode-portrait-1 #p2-controls {
            top: 10px; left: 0; width: 100%;
            justify-content: space-between; padding: 0 10px;
            align-items: flex-end;
            transform: rotate(180deg); /* Flip controls for P2 */
        }
        
        /* Fix P2 Dpad logic for inverted view (Swap Up/Down + Left/Right) */
        body.mode-portrait-1 #p2-controls .btn-up { grid-row: 3; }   
        body.mode-portrait-1 #p2-controls .btn-down { grid-row: 1; } 
        body.mode-portrait-1 #p2-controls .btn-left { grid-column: 3; }
        body.mode-portrait-1 #p2-controls .btn-right { grid-column: 1; }


        /* =========================================
           MODE 3: PORTRAIT 2 (OVERLAY / SAME SIDE)
           ========================================= */
        /* Layout: Map (Top) -> Info Bar (Bottom) */
        
        body.mode-portrait-2 #game-container { display: flex; flex-direction: column; }
        
        /* MAP (Top) */
        body.mode-portrait-2 #game-wrapper { flex: 1; order: 1; }
        
        /* SHARED MATH (Top Center of Map) */
        body.mode-portrait-2 #shared-math-display { display: block; }

        /* CONTROLS (Raised to Top Corners) */
        body.mode-portrait-2 .controls-layer { display: block; }
        
        /* P1: Top Left */
        body.mode-portrait-2 #p1-controls {
            top: 10px; left: 10px;
            flex-direction: column-reverse; /* Shoot below Dpad */
            align-items: flex-start;
        }
        
        /* P2: Top Right */
        body.mode-portrait-2 #p2-controls {
            top: 10px; right: 10px;
            flex-direction: column-reverse; /* Shoot below Dpad */
            align-items: flex-end;
        }

        /* STATUS BAR (Bottom) */
        body.mode-portrait-2 #bottom-status-container {
            order: 2; display: flex; width: 100%; height: 50px; background: #2c3e50;
        }
        body.mode-portrait-2 #p1-info-bar, 
        body.mode-portrait-2 #p2-info-bar {
            width: 50%; height: 100%; border: none; padding: 5px;
            transform: none; /* Reset rotation from P1 mode */
        }
        body.mode-portrait-2 #p1-info-bar { border-right: 2px solid #7f8c8d; }
        
        /* Hide individual math boxes in P2 Mode (using Shared) */
        body.mode-portrait-2 .math-box { display: none; }


        /* Modal styling */
        #game-over-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); border: 4px solid #fff; padding: 20px;
            text-align: center; display: none; z-index: 200; width: 80%; max-width: 400px;
        }
        #btn-restart {
            margin-top: 20px; padding: 15px; width: 100%; background: #e74c3c;
            color: white; border: none; font-family: inherit;
        }

        /* Hide elements not needed for specific modes via JS/CSS combo helper */
        body:not(.mode-portrait-2) #bottom-status-container { display: contents; } /* Allow normal flow in P1 mode */

    </style>
</head>
<body>

    <div id="start-screen">
        <h1>MATH TANK BATTLE<br>PvP</h1>
        <button class="mode-btn" onclick="startGame('portrait-1')">PORTRAIT MODE 1<br>(Head-to-Head)</button>
        <button class="mode-btn" onclick="startGame('portrait-2')">PORTRAIT MODE 2<br>(Overlay / Same Side)</button>
    </div>

    <div id="game-container">
        
        <div id="p2-info-bar" class="player-info-bar" style="color: #3498db;">
            <div class="player-stats" id="p2-stats">P2 HP: 5 | AMMO: 0</div>
            <div id="p2-math" class="math-box">WAITING...</div>
        </div>

        <div id="game-wrapper">
            <canvas id="game-canvas" width="800" height="600"></canvas>
            
            <div id="shared-math-display">WAITING...</div>

            <div class="controls-layer">
                <div id="p1-controls" class="controls-group">
                    <div class="dpad">
                        <div class="btn btn-up" data-key="KeyW">W</div>
                        <div class="btn btn-left" data-key="KeyA">A</div>
                        <div class="btn btn-down" data-key="KeyS">S</div>
                        <div class="btn btn-right" data-key="KeyD">D</div>
                    </div>
                    <div class="btn btn-shoot" data-key="Space">SHOOT</div>
                </div>

                <div id="p2-controls" class="controls-group">
                    <div class="btn btn-shoot" data-key="Enter">SHOOT</div>
                    <div class="dpad">
                        <div class="btn btn-up" data-key="ArrowUp">â–²</div>
                        <div class="btn btn-left" data-key="ArrowLeft">â—„</div>
                        <div class="btn btn-down" data-key="ArrowDown">â–¼</div>
                        <div class="btn btn-right" data-key="ArrowRight">â–º</div>
                    </div>
                </div>
            </div>

            <div id="game-over-modal">
                <h2 id="winner-text">WINNER</h2>
                <p id="win-reason">Reason</p>
                <button id="btn-restart">PLAY AGAIN</button>
            </div>
        </div>

        <div id="bottom-status-container">
            <div id="p1-info-bar" class="player-info-bar" style="color: #2ecc71;">
                <div class="player-stats" id="p1-stats">P1 HP: 5 | AMMO: 0</div>
                <div id="p1-math" class="math-box">WAITING...</div>
            </div>
        </div>

    </div>

<script>
/** * --- GAME LOGIC --- */

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 40;
const MAP_ROWS = 15; 
const MAP_COLS = 20; 
const keys = {};

// Audio
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function initAudio() { if (!audioCtx) { audioCtx = new AudioContext(); } if (audioCtx.state === 'suspended') { audioCtx.resume(); } }
function playSound(type) {
    if (!audioCtx || audioCtx.state === 'suspended') return;
    const osc = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
    osc.connect(gainNode); gainNode.connect(audioCtx.destination);
    if (type === 'shoot') {
        osc.type = 'square'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
        gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'damage') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.2);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }
}

// Variables
let gameOver = false; let mathProblem = null; let mathTimer = 0;
let items = []; let bullets = []; let particles = []; let floatingTexts = [];
let p1, p2; let walls = []; let animationFrameId = null;

const INITIAL_MAP = [
    [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0], 
    [0,0,0,0,0,0,0,0,2,9,2,0,0,0,0,0,0,0,0,0], 
    [0,0,1,1,1,0,0,0,2,2,2,0,0,0,1,1,1,0,0,0], 
    [0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],
    [0,0,1,1,1,0,2,1,0,0,0,1,2,0,1,1,1,0,0,0],
    [0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0],
    [0,1,0,1,2,2,2,0,0,0,0,0,2,2,2,1,0,1,0,0],
    [0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0], 
    [0,1,0,1,2,2,2,0,0,0,0,0,2,2,2,1,0,1,0,0],
    [0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0],
    [0,0,1,1,1,0,2,1,0,0,0,1,2,0,1,1,1,0,0,0],
    [0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],
    [0,0,1,1,1,0,0,0,2,2,2,0,0,0,1,1,1,0,0,0], 
    [0,0,0,0,0,0,0,0,2,9,2,0,0,0,0,0,0,0,0,0], 
    [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0]  
];
const BASES = [
    { id: 1, x: 9.5 * TILE_SIZE, y: 13.5 * TILE_SIZE, hp: 5, owner: 1, active: true },
    { id: 2, x: 9.5 * TILE_SIZE, y: 1.5 * TILE_SIZE, hp: 5, owner: 2, active: true } 
];

class Tank {
    constructor(id, x, y, color, controls) {
        this.id = id; this.x = x; this.y = y; this.width = 30; this.height = 30;
        this.color = color; this.controls = controls; this.speed = 3; this.dir = 0; 
        this.hp = 5; this.ammo = 0; this.shootCooldown = 0; this.invulnerable = 0;
    }
    update() {
        if (this.hp <= 0) return;
        if (this.shootCooldown > 0) this.shootCooldown--;
        if (this.invulnerable > 0) this.invulnerable--;
        let dx = 0, dy = 0;
        if (keys[this.controls.up]) { dy = -this.speed; this.dir = 0; }
        else if (keys[this.controls.down]) { dy = this.speed; this.dir = 2; }
        else if (keys[this.controls.left]) { dx = -this.speed; this.dir = 3; }
        else if (keys[this.controls.right]) { dx = this.speed; this.dir = 1; }
        if (dx !== 0 || dy !== 0) {
            if (!this.checkCollision(this.x + dx, this.y)) this.x += dx;
            if (!this.checkCollision(this.x, this.y + dy)) this.y += dy;
        }
        this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
        this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
        if (keys[this.controls.shoot] && this.shootCooldown <= 0 && this.ammo > 0) { this.shoot(); }
        this.checkItemCollection();
    }
    checkCollision(newX, newY) {
        let rect = {x: newX, y: newY, w: this.width, h: this.height};
        for (let w of walls) { if (rectIntersect(rect, w)) return true; }
        let other = this.id === 1 ? p2 : p1;
        if (other.hp > 0 && rectIntersect(rect, {x: other.x, y: other.y, w: other.width, h: other.height})) return true;
        for (let b of BASES) { if (b.active && rectIntersect(rect, {x: b.x - 15, y: b.y - 15, w: 30, h: 30})) return true; }
        return false;
    }
    checkItemCollection() {
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            if (rectIntersect({x: this.x, y: this.y, w: this.width, h: this.height}, {x: item.x, y: item.y, w: TILE_SIZE-4, h: TILE_SIZE-4})) {
                if (item.isCorrect) { this.ammo += 3; createFloatingText(this.x, this.y, "+3 AMMO", "#2ecc71"); }
                else if (this.invulnerable <= 0) { this.hp -= 1; this.invulnerable = 60; playSound('damage'); createFloatingText(this.x, this.y, "-1 HP", "#e74c3c"); checkWinCondition(); }
                items.splice(i, 1);
            }
        }
    }
    shoot() {
        this.ammo--; this.shootCooldown = 30; playSound('shoot');
        let bx = this.x + this.width/2, by = this.y + this.height/2;
        let speed = 7, vx = 0, vy = 0;
        if (this.dir === 0) { vy = -speed; by -= 20; }
        if (this.dir === 1) { vx = speed; bx += 20; }
        if (this.dir === 2) { vy = speed; by += 20; }
        if (this.dir === 3) { vx = -speed; bx -= 20; }
        bullets.push(new Bullet(bx, by, vx, vy, this.id));
    }
    draw() {
        if (this.hp <= 0) return;
        ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); ctx.rotate(this.dir * 90 * (Math.PI/180));
        ctx.fillStyle = this.color; if (this.invulnerable > 0 && Math.floor(Date.now()/100)%2===0) ctx.fillStyle = "#fff";
        ctx.fillRect(-15, -15, 8, 30); ctx.fillRect(7, -15, 8, 30);
        ctx.fillStyle = this.color; if (this.invulnerable > 0 && Math.floor(Date.now()/100)%2===0) ctx.fillStyle = "#fff";
        ctx.fillRect(-8, -12, 16, 24); ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill(); ctx.fillRect(-2, -18, 4, 18);
        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, vx, vy, ownerId) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.ownerId = ownerId; this.active = true; }
    update() {
        this.x += this.vx; this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) { this.active = false; return; }
        for (let i = walls.length - 1; i >= 0; i--) {
            let w = walls[i];
            if (this.x > w.x && this.x < w.x + w.w && this.y > w.y && this.y < w.y + w.h) {
                this.active = false; createExplosion(this.x, this.y, "orange"); if (w.type === 1) walls.splice(i, 1); return;
            }
        }
        for (let base of BASES) {
            if (!base.active) continue;
            if (Math.hypot(this.x - base.x, this.y - base.y) < 20) {
                this.active = false; base.hp--; createExplosion(base.x, base.y, "yellow"); playSound('damage'); createFloatingText(base.x - 10, base.y - 10, "-1 HP", "#f1c40f");
                if (base.hp <= 0) { base.active = false; createExplosion(base.x, base.y, "red", 50); endGame((base.owner === 1 ? "Player 2" : "Player 1"), "Base Destroyed!"); }
                return;
            }
        }
        let target = this.ownerId === 1 ? p2 : p1;
        if (target.hp > 0 && this.x > target.x && this.x < target.x + target.width && this.y > target.y && this.y < target.y + target.height) {
            this.active = false; target.hp--; playSound('damage'); createExplosion(this.x, this.y, "red"); checkWinCondition();
        }
    }
    draw() { ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill(); }
}

class Particle {
    constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random()-0.5)*5; this.vy = (Math.random()-0.5)*5; this.life = 1.0; this.color = color; }
    update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
    draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1.0; }
}

function rectIntersect(r1, r2) { return !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || r2.y > r1.y + r1.h || r2.y + r2.h < r1.y); }
function createExplosion(x, y, color, count=10) { for(let i=0; i<count; i++) particles.push(new Particle(x, y, color)); }
function createFloatingText(x, y, text, color) { floatingTexts.push({x, y, text, color, life: 1.0}); }
function generateMathProblem() {
    let isAdd = Math.random() > 0.5; let a = Math.floor(Math.random()*9)+1; let b = Math.floor(Math.random()*9)+1;
    if (!isAdd && b > a) { let t = a; a = b; b = t; }
    let ans = isAdd ? a + b : a - b;
    spawnMathItems([ans, ans+Math.floor(Math.random()*5)+1, ans-Math.floor(Math.random()*4)-1].sort(()=>Math.random()-0.5), ans);
    return { text: `${a} ${isAdd ? "+" : "-"} ${b} = ?`, answer: ans };
}
function spawnMathItems(values, correctVal) {
    items = [];
    values.forEach(val => {
        let placed = false, attempts = 0;
        while (!placed && attempts < 50) {
            let c = Math.floor(Math.random()*MAP_COLS), r = Math.floor(Math.random()*MAP_ROWS);
            if (INITIAL_MAP[r][c] !== 0) { attempts++; continue; }
            let x = c * TILE_SIZE + 2, y = r * TILE_SIZE + 2;
            if (Math.hypot(x-p1.x, y-p1.y) < 60 || Math.hypot(x-p2.x, y-p2.y) < 60) { attempts++; continue; }
            let rotation = Math.random() > 0.5 ? Math.PI : 0;
            items.push({x, y, val, isCorrect: val === correctVal, creationTime: Date.now(), rotation: rotation});
            placed = true;
        }
    });
}
function updateMathLogic() {
    if (gameOver) return;
    if (!mathProblem) { if (items.length === 0) { mathProblem = generateMathProblem(); mathTimer = 600; } }
    else { mathTimer--; if (mathTimer <= 0) { mathProblem = null; items = []; } else if (items.length === 0) mathProblem = null; }
}
function checkWinCondition() { if (p1.hp <= 0) endGame("Player 2", "Player 1 Destroyed!"); if (p2.hp <= 0) endGame("Player 1", "Player 2 Destroyed!"); }
function endGame(winner, reason) { if (gameOver) return; gameOver = true; document.getElementById('winner-text').innerText = winner + " WINS!"; document.getElementById('win-reason').innerText = reason; document.getElementById('game-over-modal').style.display = "block"; }

function updateUI() {
    document.getElementById('p1-stats').innerText = `P1 HP: ${p1.hp} | AMMO: ${p1.ammo}`;
    document.getElementById('p2-stats').innerText = `P2 HP: ${p2.hp} | AMMO: ${p2.ammo}`;
    
    let mathText = "WAITING...";
    let styleColor = "#95a5a6";
    if (mathProblem) {
        mathText = `${mathProblem.text} <span style="font-size:0.7em">(${Math.ceil(mathTimer / 60)}s)</span>`;
        styleColor = "#f1c40f";
    }
    document.getElementById('p1-math').innerHTML = mathText; document.getElementById('p1-math').style.borderColor = styleColor;
    document.getElementById('p2-math').innerHTML = mathText; document.getElementById('p2-math').style.borderColor = styleColor;
    
    // Shared Display update
    document.getElementById('shared-math-display').innerHTML = mathText;
}

function drawMap() {
    walls.forEach(w => {
        if (w.type === 1) { ctx.fillStyle = "#d35400"; ctx.fillRect(w.x, w.y, w.w, w.h); ctx.fillStyle = "#e67e22"; ctx.fillRect(w.x+2, w.y+2, w.w-4, w.h-4); }
        else if (w.type === 2) { ctx.fillStyle = "#bdc3c7"; ctx.fillRect(w.x, w.y, w.w, w.h); ctx.fillStyle = "#ecf0f1"; ctx.fillRect(w.x+5, w.y+5, w.w-10, w.h-10); }
        else if (w.type === 3) { ctx.fillStyle = "#2980b9"; ctx.fillRect(w.x, w.y, w.w, w.h); }
    });
    BASES.forEach(b => {
        if (!b.active) return;
        ctx.fillStyle = b.owner === 1 ? "#27ae60" : "#2980b9"; ctx.beginPath(); ctx.arc(b.x, b.y, 15, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#f1c40f"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.font="20px Arial"; ctx.fillText(b.owner === 1 ? "ðŸ¦…" : "â­", b.x, b.y+2);
    });
}

function gameLoop() {
    if (gameOver) return;
    p1.update(); p2.update();
    bullets.forEach(b => b.update()); bullets = bullets.filter(b => b.active);
    particles.forEach(p => p.update()); particles = particles.filter(p => p.life > 0);
    floatingTexts.forEach(ft => ft.life -= 0.02); floatingTexts = floatingTexts.filter(ft => ft.life > 0);
    updateMathLogic(); updateUI();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap();
    items.forEach(item => {
        ctx.fillStyle = "#9b59b6"; ctx.fillRect(item.x, item.y, 36, 36); ctx.strokeStyle = "#fff"; ctx.strokeRect(item.x, item.y, 36, 36);
        ctx.save(); ctx.translate(item.x + 18, item.y + 18); ctx.rotate(item.rotation);
        ctx.fillStyle = "#fff"; ctx.font = "bold 16px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(item.val, 0, 0);
        if (item.val === 6 || item.val === 9) { ctx.beginPath(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.moveTo(-6, 8); ctx.lineTo(6, 8); ctx.stroke(); }
        ctx.restore();
    });
    BASES.forEach(b => { if(!b.active) { ctx.fillStyle = "#555"; ctx.fillRect(b.x-15, b.y-15, 30, 30); } });
    bullets.forEach(b => b.draw()); p1.draw(); p2.draw(); particles.forEach(p => p.draw());
    floatingTexts.forEach(ft => { ctx.fillStyle = ft.color; ctx.globalAlpha = Math.max(0, ft.life); ctx.font = "bold 14px sans-serif"; ctx.fillText(ft.text, ft.x, ft.y - (1.0 - ft.life) * 20); ctx.globalAlpha = 1.0; });
    animationFrameId = requestAnimationFrame(gameLoop);
}

function startGame(mode) {
    initAudio();
    document.getElementById('start-screen').style.display = 'none';
    document.body.className = 'mode-' + mode;
    initGame();
}

function bindControls() {
    const buttons = document.querySelectorAll('.btn, .btn-shoot');
    buttons.forEach(btn => {
        const key = btn.getAttribute('data-key'); if(!key) return;
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; btn.classList.add('pressed'); initAudio(); }, {passive: false});
        btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; btn.classList.remove('pressed'); });
        btn.addEventListener('mousedown', (e) => { keys[key] = true; btn.classList.add('pressed'); initAudio(); });
        btn.addEventListener('mouseup', (e) => { keys[key] = false; btn.classList.remove('pressed'); });
        btn.addEventListener('mouseleave', (e) => { keys[key] = false; btn.classList.remove('pressed'); });
    });
    window.addEventListener('keydown', e => { keys[e.code] = true; if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code)>-1)e.preventDefault(); initAudio(); });
    window.addEventListener('keyup', e => keys[e.code] = false);
    document.getElementById('btn-restart').addEventListener('click', () => { initGame(); });
}

function initGame() {
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    walls = [];
    for (let r = 0; r < MAP_ROWS; r++) { for (let c = 0; c < MAP_COLS; c++) { let code = INITIAL_MAP[r][c]; if (code === 1 || code === 2 || code === 3) walls.push({x: c*40, y: r*40, w: 40, h: 40, type: code}); } }
    p1 = new Tank(1, 165, 525, "#2ecc71", {up: "KeyW", down: "KeyS", left: "KeyA", right: "KeyD", shoot: "Space"});
    p2 = new Tank(2, 605, 45, "#3498db", {up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", shoot: "Enter"});
    BASES.forEach(b => { b.hp = 5; b.active = true; });
    bullets = []; items = []; particles = []; floatingTexts = []; gameOver = false; mathTimer = 0; mathProblem = null;
    document.getElementById('game-over-modal').style.display = "none";
    gameLoop();
}

bindControls();
</script>
</body>
</html>
